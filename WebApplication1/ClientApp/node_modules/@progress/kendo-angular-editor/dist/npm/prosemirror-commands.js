"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var prosemirror_commands_1 = require("prosemirror-commands");
var prosemirror_state_1 = require("prosemirror-state");
var prosemirror_schema_list_1 = require("prosemirror-schema-list");
var prosemirror_core_utils_1 = require("./prosemirror-core-utils");
var prosemirror_utils_1 = require("./prosemirror-utils");
var util_1 = require("./util");
var indent_rules_1 = require("./config/indent-rules");
var schema_1 = require("./config/schema");
var _a = schema_1.schema.nodes, blockquote = _a.blockquote, heading = _a.heading, listItem = _a.listItem, paragraph = _a.paragraph, image = _a.image;
/**
 * @hidden
 */
exports.removeMark = function (markType) { return function (state, dispatch) {
    var _a = state.selection, from = _a.from, to = _a.to, $cursor = _a.$cursor;
    if ($cursor) {
        var resolvedRange = prosemirror_core_utils_1.getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
}; };
/**
 * @hidden
 */
exports.removeAllMarks = function (_a) {
    var _b = (_a === void 0 ? {} : _a).except, except = _b === void 0 ? [] : _b;
    return function (state, dispatch) {
        var _a = state.selection, $cursor = _a.$cursor, from = _a.from, to = _a.to;
        var tr = state.tr;
        var excludedMarkTypes = util_1.toArray(except).map(function (mt) { return mt.name; });
        if (!$cursor) {
            Object.keys(schema_1.schema.marks)
                .map(function (m) { return schema_1.schema.marks[m]; })
                .filter(function (mt) { return excludedMarkTypes.indexOf(mt.name) === -1; })
                .forEach(function (mt) { return tr.removeMark(from, to, mt); });
            dispatch(tr);
        }
    };
};
/**
 * @hidden
 */
exports.toggleBold = prosemirror_commands_1.toggleMark(schema_1.schema.marks.strong);
/**
 * @hidden
 */
exports.toggleItalic = prosemirror_commands_1.toggleMark(schema_1.schema.marks.em);
/**
 * @hidden
 */
exports.toggleUnderline = prosemirror_commands_1.toggleMark(schema_1.schema.marks.underline);
/**
 * @hidden
 */
exports.toggleStrikethrough = prosemirror_commands_1.toggleMark(schema_1.schema.marks.strikethrough);
/**
 * @hidden
 */
exports.toggleSubscript = prosemirror_commands_1.toggleMark(schema_1.schema.marks.subscript);
/**
 * @hidden
 */
exports.toggleSuperscript = prosemirror_commands_1.toggleMark(schema_1.schema.marks.superscript);
/**
 * @hidden
 */
exports.setFontFamily = function (font) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = prosemirror_core_utils_1.changeStyle(marks.style, {
        newValue: font,
        style: 'font-family',
        value: /^.+$/
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
exports.setFontSize = function (size) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = prosemirror_core_utils_1.changeStyle(marks.style, {
        newValue: size + "px",
        style: 'font-size',
        value: /^.+$/
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
exports.createLink = function (attrs) { return function (state, dispatch) {
    if (prosemirror_utils_1.isMarkActive(state, schema_1.schema.marks.link)) {
        prosemirror_core_utils_1.modifyMark(schema_1.schema.marks.link, attrs)(state, dispatch);
    }
    else if (state.selection.empty) {
        if (core_1.isDevMode() && !util_1.isPresent(attrs.text)) {
            throw new Error(
            // tslint:disable-next-line:max-line-length
            "Unable to create link without text. Please pass a 'text' property as part of the parameter or select any text in the Editor.");
        }
        var newLink = schema_1.schema.text(attrs.text, [schema_1.schema.marks.link.create(attrs)].concat(prosemirror_utils_1.getActiveMarks(state).marks));
        dispatch(state.tr.replaceSelectionWith(newLink, false));
    }
    else {
        prosemirror_commands_1.toggleMark(schema_1.schema.marks.link, attrs)(state, dispatch);
    }
}; };
/**
 * @hidden
 */
exports.addOrUpdateStyle = function (cssProp, value) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var selectionPresent = !state.selection.empty;
    if (selectionPresent || prosemirror_utils_1.isMarkActive(state, marks.style)) {
        var cmd = prosemirror_core_utils_1.changeStyle(marks.style, {
            style: cssProp,
            value: /^.+$/,
            newValue: value
        });
        cmd(state, dispatch);
    }
    else {
        var styles = marks.style.create({ style: cssProp + ": " + value });
        var transaction = state.tr.addStoredMark(styles);
        dispatch(transaction);
    }
}; };
/**
 * @hidden
 */
exports.applyHeading = function (level) { return prosemirror_commands_1.setBlockType(heading, { level: level }); };
/**
 * @hidden
 */
exports.applyParagraph = prosemirror_commands_1.setBlockType(paragraph);
/**
 * @hidden
 */
exports.applyBlockquote = prosemirror_commands_1.setBlockType(blockquote);
/**
 * @hidden
 */
exports.format = function (_a) {
    var tag = _a.tag;
    if (tag.match(/h\d\b/)) {
        return exports.applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return exports.applyParagraph;
    }
    else if (tag === 'blockquote') {
        return exports.applyBlockquote;
    }
};
/**
 * @hidden
 */
exports.insertImage = function (attrs) { return function (state, dispatch) {
    var node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
}; };
/**
 * @hidden
 */
exports.insertText = function (attrs) { return function (state, dispatch) {
    dispatch(state.tr.insertText(attrs.text, attrs.from, attrs.to));
}; };
/**
 * @hidden
 */
exports.setHTML = function (content) { return function (state, dispatch) {
    return dispatch(state.tr.setSelection(new prosemirror_state_1.AllSelection(state.doc)).replaceSelectionWith(prosemirror_utils_1.createContentNode(content)));
}; };
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
exports.alignBlocks = function (actions) { return function (state, dispatch) {
    var blocks = prosemirror_utils_1.blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = {};
            var action = actions.find(function (n) { return n.node === node.type.name; });
            if (action) {
                newAttrs = prosemirror_core_utils_1.addStyles(node, action.style);
            }
            result = prosemirror_core_utils_1.changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
/**
 * Indenting block elements in the selection.
 *
 * @returns {boolean} - Returns true if any indentation is applied.
 */
var indentBlocks = function (actions) { return function (state, dispatch) {
    var blocks = prosemirror_utils_1.blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = void 0;
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                var newStyle = {
                    name: action.style,
                    value: action.step > 0 ? "" + action.step + action.unit : ''
                };
                if (node.attrs.style) {
                    var re = new RegExp(action.style + ":\\s?(\\d+)" + action.unit, 'i');
                    var match = node.attrs.style.match(re);
                    if (match) {
                        var newMargin = parseFloat(match[1]) + action.step;
                        newMargin = newMargin <= 0 ? '' : newMargin;
                        newStyle.value = "" + newMargin + (newMargin ? action.unit : '');
                    }
                }
                newAttrs = prosemirror_core_utils_1.addStyles(node, [newStyle]);
            }
            if (newAttrs) {
                result = prosemirror_core_utils_1.changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
            }
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
var ɵ0 = indentBlocks;
exports.ɵ0 = ɵ0;
/**
 * @hidden
 */
exports.indent = function (state, dispatch) {
    var isIndentableBlock = prosemirror_utils_1.canBeIndented(state, indent_rules_1.indentRules);
    if (prosemirror_utils_1.canIndentAsListItem(state)) {
        prosemirror_schema_list_1.sinkListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(indent_rules_1.indentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
exports.outdent = function (state, dispatch) {
    var isIndentableBlock = prosemirror_utils_1.canBeIndented(state, indent_rules_1.outdentRules);
    if (prosemirror_utils_1.canOutdentAsListItem(state)) {
        prosemirror_schema_list_1.liftListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(indent_rules_1.outdentRules)(state, dispatch);
    }
};
