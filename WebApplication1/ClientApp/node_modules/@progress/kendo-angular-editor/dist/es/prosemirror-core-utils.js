import { Fragment, Slice } from 'prosemirror-model';
import { ReplaceAroundStep, RemoveMarkStep, AddMarkStep } from 'prosemirror-transform';
var changeStyles = function (elementStyle, newStyle) {
    var styleToChange = newStyle.style;
    var regExp = newStyle.value;
    var newValue = newStyle.newValue;
    var styleMatches = [];
    if (elementStyle) {
        var splits = elementStyle.split(/\s*;\s*/).filter(function (s) { return s; });
        var filtered = splits.filter(function (s) {
            if (!s
                .toLowerCase()
                .trim()
                .startsWith(styleToChange)) {
                return true;
            }
            var value = s.split(':')[1].trim();
            if (regExp.test(value)) {
                styleMatches.push(value);
                return false;
            }
            return true;
        });
        if (newValue) {
            filtered.push(styleToChange + ": " + newValue);
        }
        return {
            changed: !!newValue || filtered.length !== splits.length,
            style: filtered.join('; ') + (filtered.length ? ';' : ''),
            styleMatches: styleMatches
        };
    }
    return { changed: false, styleMatches: styleMatches, style: null };
};
var ɵ0 = changeStyles;
var changeStyleFromMark = function (marks, toChange) {
    var styleMark = marks.find(function (m) { return m.type.name === 'style'; });
    var elementStyle = styleMark && styleMark.attrs.style;
    return changeStyles(elementStyle, toChange);
};
var ɵ1 = changeStyleFromMark;
var changeStyleMark = function (tr, from, to, attrs, markType) {
    var mark = markType.create({ style: attrs.style });
    var removed = [], added = [], removing = null, adding = null;
    tr.doc.nodesBetween(from, to, function (node, pos, parent) {
        if (!node.isInline) {
            return;
        }
        var marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
            var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
            var newStyle = changeStyleFromMark(marks, attrs);
            if (newStyle.changed || attrs.newValue) {
                var style = newStyle.changed ? { style: newStyle.style } : { style: [attrs.style] + ": " + attrs.newValue + ";" };
                var newStyleMark = markType.create(style);
                var newSet = newStyleMark.addToSet(marks);
                for (var i = 0; i < marks.length; i++) {
                    if (!marks[i].isInSet(newSet)) {
                        if (removing && removing.to === start && removing.mark.eq(marks[i])) {
                            removing.to = end;
                        }
                        else {
                            removing = new RemoveMarkStep(start, end, marks[i]);
                            removed.push(removing);
                        }
                    }
                }
                var previousAdded = adding && adding.to === start;
                var sameAdding = previousAdded && newStyleMark.attrs.style === adding.mark.attrs.style;
                if (previousAdded && sameAdding) {
                    adding.to = end;
                }
                else if (newStyleMark.attrs.style) {
                    adding = new AddMarkStep(start, end, newStyleMark);
                    added.push(adding);
                }
            }
        }
    });
    removed.forEach(function (s) { return tr.step(s); });
    added.forEach(function (s) { return tr.step(s); });
    return removed.length + added.length > 0;
};
var ɵ2 = changeStyleMark;
var markApplies = function (doc, ranges, type) {
    var loop = function (i) {
        var ref = ranges[i];
        var $from = ref.$from;
        var $to = ref.$to;
        var can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, function (node) {
            if (can) {
                return false;
            }
            can = node.inlineContent && node.type.allowsMarkType(type);
        });
        if (can) {
            return { v: true };
        }
    };
    for (var i = 0; i < ranges.length; i++) {
        var returned = loop(i);
        if (returned) {
            return returned.v;
        }
    }
    return false;
};
var ɵ3 = markApplies;
/**
 * @hidden
 */
export var changeStyle = function (markType, attrs) {
    return function (state, dispatch, tr) {
        var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor, ranges = _a.ranges;
        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) {
            return false;
        }
        var result = false;
        if (dispatch) {
            tr = tr || state.tr;
            if ($cursor) {
                var currentMarks = state.storedMarks || $cursor.marks();
                if (markType.isInSet(currentMarks)) {
                    var newStyle = changeStyleFromMark(currentMarks, attrs);
                    dispatch(tr.removeStoredMark(markType));
                    dispatch(tr.addStoredMark(markType.create({ style: newStyle.style })));
                    result = true;
                }
            }
            else {
                for (var i = 0; i < ranges.length; i++) {
                    var _b = ranges[i], $from = _b.$from, $to = _b.$to;
                    result = changeStyleMark(tr, $from.pos, $to.pos, attrs, markType);
                }
                if (result) {
                    tr.scrollIntoView();
                    dispatch(tr);
                }
            }
        }
        return result;
    };
};
var canChangeType = function (stateDoc, pos, type) {
    var $pos = stateDoc.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
};
var ɵ4 = canChangeType;
/**
 * @hidden
 */
export var changeBlockNode = function (state, dispatch, tr, node, nodeType, attrs) {
    var _a = state.selection, from = _a.from, to = _a.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (currNode, pos) {
        if (applicable) {
            return false;
        }
        if (!currNode.isTextblock || currNode.hasMarkup(nodeType, attrs)) {
            return;
        }
        if (currNode.type === nodeType) {
            applicable = true;
        }
        else {
            var $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
    });
    if (!applicable) {
        return false;
    }
    if (dispatch) {
        if (!nodeType.isTextblock) {
            throw new RangeError('Type given to setBlockType should be a textblock');
        }
        var mapFrom_1 = tr.steps.length;
        tr.doc.nodesBetween(from, to, function (currNode, pos) {
            if (currNode.eq(node) &&
                currNode.isTextblock &&
                !currNode.hasMarkup(nodeType, attrs) &&
                canChangeType(tr.doc, tr.mapping.slice(mapFrom_1).map(pos), nodeType)) {
                // Ensure all markup that isn't allowed in the new node type is cleared
                tr.clearIncompatible(tr.mapping.slice(mapFrom_1).map(pos, 1), nodeType);
                var mapping = tr.mapping.slice(mapFrom_1);
                var startM = mapping.map(pos, 1), endM = mapping.map(pos + currNode.nodeSize, 1);
                var slice = new Slice(Fragment.from(nodeType.create(attrs, null, currNode.marks)), 0, 0);
                tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, slice, 1, true));
                return false; // this will skip the node children
            }
        });
    }
    return true;
};
/**
 * @hidden
 */
export function getMarkRange($cursor, markType) {
    var parentNode = $cursor.parent;
    var cursorNodeIndex = $cursor.index();
    var mark = parentNode.child(cursorNodeIndex).marks.find(function (m) { return m.type === markType; });
    var childCount = parentNode.childCount;
    var start = $cursor.pos - $cursor.textOffset, end = parentNode.child(cursorNodeIndex).nodeSize, index, nodeSize;
    index = cursorNodeIndex - 1;
    while (index >= 0 && mark.isInSet(parentNode.child(index).marks)) {
        nodeSize = parentNode.child(index).nodeSize;
        end += nodeSize;
        start -= nodeSize;
        index -= 1;
    }
    index = cursorNodeIndex + 1;
    while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
        end += parentNode.child(index).nodeSize;
        index += 1;
    }
    return { from: start, to: start + end };
}
/**
 * @hidden
 */
export var modifyMark = function (markType, attrs) { return function (state, dispatch) {
    var tr = state.tr;
    var _a = state.selection, $cursor = _a.$cursor, from = _a.from, to = _a.to;
    if (!$cursor) {
        tr.doc.nodesBetween(from, to, function (node, pos) {
            if (node.isInline && markType.isInSet(node.marks)) {
                tr.removeMark(pos, pos + node.nodeSize, markType);
                tr.addMark(pos, pos + node.nodeSize, markType.create(attrs));
                dispatch(tr);
            }
        });
    }
    else {
        var parentNode = $cursor.parent;
        var cursorNodeIndex = $cursor.index();
        var mark = parentNode.child(cursorNodeIndex).marks.find(function (m) { return m.type === markType; });
        var childCount = parentNode.childCount;
        var markStart = $cursor.pos - $cursor.textOffset, markSize = parentNode.child(cursorNodeIndex).nodeSize, index = void 0, nodeSize = void 0;
        index = cursorNodeIndex - 1;
        while (index >= 0 && mark && mark.isInSet(parentNode.child(index).marks)) {
            nodeSize = parentNode.child(index).nodeSize;
            markSize += nodeSize;
            markStart -= nodeSize;
            index -= 1;
        }
        index = cursorNodeIndex + 1;
        while (index < childCount && mark.isInSet(parentNode.child(index).marks)) {
            markSize += parentNode.child(index).nodeSize;
            index += 1;
        }
        tr.removeMark(markStart, markStart + markSize, markType);
        tr.addMark(markStart, markStart + markSize, markType.create(attrs));
        dispatch(tr);
    }
}; };
/**
 * @hidden
 */
export var addStyles = function (node, stylesToApply) {
    var currentStyles = node.attrs.style, changedStyleResult = null, toChange = null;
    if (currentStyles) {
        stylesToApply.forEach(function (style) {
            toChange = { style: style.name, value: /^.+$/, newValue: style.value };
            changedStyleResult = changeStyles(currentStyles, toChange);
            currentStyles = changedStyleResult.changed ? changedStyleResult.style : currentStyles;
        });
    }
    var reducer = function (acc, curr) { return ((acc && curr.value ? acc + ' ' : '') + curr.value ? curr.name + ": " + curr.value + ";" : ''); };
    currentStyles = currentStyles || stylesToApply.reduce(reducer, '');
    return Object.assign({}, node.attrs, { style: currentStyles || null });
};
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4 };
