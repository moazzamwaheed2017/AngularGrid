import { isDevMode } from '@angular/core';
import { toggleMark, setBlockType } from 'prosemirror-commands';
import { AllSelection } from 'prosemirror-state';
import { sinkListItem, liftListItem } from 'prosemirror-schema-list';
import { getMarkRange, modifyMark, addStyles, changeBlockNode, changeStyle } from './prosemirror-core-utils';
import { isMarkActive, getActiveMarks, blockNodes, createContentNode, canBeIndented, canIndentAsListItem, canOutdentAsListItem } from './prosemirror-utils';
import { isPresent, toArray } from './util';
import { indentRules, outdentRules } from './config/indent-rules';
import { schema } from './config/schema';
var _a = schema.nodes, blockquote = _a.blockquote, heading = _a.heading, listItem = _a.listItem, paragraph = _a.paragraph, image = _a.image;
/**
 * @hidden
 */
export var removeMark = function (markType) { return function (state, dispatch) {
    var _a = state.selection, from = _a.from, to = _a.to, $cursor = _a.$cursor;
    if ($cursor) {
        var resolvedRange = getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
}; };
/**
 * @hidden
 */
export var removeAllMarks = function (_a) {
    var _b = (_a === void 0 ? {} : _a).except, except = _b === void 0 ? [] : _b;
    return function (state, dispatch) {
        var _a = state.selection, $cursor = _a.$cursor, from = _a.from, to = _a.to;
        var tr = state.tr;
        var excludedMarkTypes = toArray(except).map(function (mt) { return mt.name; });
        if (!$cursor) {
            Object.keys(schema.marks)
                .map(function (m) { return schema.marks[m]; })
                .filter(function (mt) { return excludedMarkTypes.indexOf(mt.name) === -1; })
                .forEach(function (mt) { return tr.removeMark(from, to, mt); });
            dispatch(tr);
        }
    };
};
/**
 * @hidden
 */
export var toggleBold = toggleMark(schema.marks.strong);
/**
 * @hidden
 */
export var toggleItalic = toggleMark(schema.marks.em);
/**
 * @hidden
 */
export var toggleUnderline = toggleMark(schema.marks.underline);
/**
 * @hidden
 */
export var toggleStrikethrough = toggleMark(schema.marks.strikethrough);
/**
 * @hidden
 */
export var toggleSubscript = toggleMark(schema.marks.subscript);
/**
 * @hidden
 */
export var toggleSuperscript = toggleMark(schema.marks.superscript);
/**
 * @hidden
 */
export var setFontFamily = function (font) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = changeStyle(marks.style, {
        newValue: font,
        style: 'font-family',
        value: /^.+$/
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
export var setFontSize = function (size) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var cmd = changeStyle(marks.style, {
        newValue: size + "px",
        style: 'font-size',
        value: /^.+$/
    });
    return cmd(state, dispatch);
}; };
/**
 * @hidden
 */
export var createLink = function (attrs) { return function (state, dispatch) {
    if (isMarkActive(state, schema.marks.link)) {
        modifyMark(schema.marks.link, attrs)(state, dispatch);
    }
    else if (state.selection.empty) {
        if (isDevMode() && !isPresent(attrs.text)) {
            throw new Error(
            // tslint:disable-next-line:max-line-length
            "Unable to create link without text. Please pass a 'text' property as part of the parameter or select any text in the Editor.");
        }
        var newLink = schema.text(attrs.text, [schema.marks.link.create(attrs)].concat(getActiveMarks(state).marks));
        dispatch(state.tr.replaceSelectionWith(newLink, false));
    }
    else {
        toggleMark(schema.marks.link, attrs)(state, dispatch);
    }
}; };
/**
 * @hidden
 */
export var addOrUpdateStyle = function (cssProp, value) { return function (state, dispatch) {
    var marks = state.schema.marks;
    var selectionPresent = !state.selection.empty;
    if (selectionPresent || isMarkActive(state, marks.style)) {
        var cmd = changeStyle(marks.style, {
            style: cssProp,
            value: /^.+$/,
            newValue: value
        });
        cmd(state, dispatch);
    }
    else {
        var styles = marks.style.create({ style: cssProp + ": " + value });
        var transaction = state.tr.addStoredMark(styles);
        dispatch(transaction);
    }
}; };
/**
 * @hidden
 */
export var applyHeading = function (level) { return setBlockType(heading, { level: level }); };
/**
 * @hidden
 */
export var applyParagraph = setBlockType(paragraph);
/**
 * @hidden
 */
export var applyBlockquote = setBlockType(blockquote);
/**
 * @hidden
 */
export var format = function (_a) {
    var tag = _a.tag;
    if (tag.match(/h\d\b/)) {
        return applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return applyParagraph;
    }
    else if (tag === 'blockquote') {
        return applyBlockquote;
    }
};
/**
 * @hidden
 */
export var insertImage = function (attrs) { return function (state, dispatch) {
    var node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
}; };
/**
 * @hidden
 */
export var insertText = function (attrs) { return function (state, dispatch) {
    dispatch(state.tr.insertText(attrs.text, attrs.from, attrs.to));
}; };
/**
 * @hidden
 */
export var setHTML = function (content) { return function (state, dispatch) {
    return dispatch(state.tr.setSelection(new AllSelection(state.doc)).replaceSelectionWith(createContentNode(content)));
}; };
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
export var alignBlocks = function (actions) { return function (state, dispatch) {
    var blocks = blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = {};
            var action = actions.find(function (n) { return n.node === node.type.name; });
            if (action) {
                newAttrs = addStyles(node, action.style);
            }
            result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
/**
 * Indenting block elements in the selection.
 *
 * @returns {boolean} - Returns true if any indentation is applied.
 */
var indentBlocks = function (actions) { return function (state, dispatch) {
    var blocks = blockNodes(state);
    var tr = state.tr;
    var result = false;
    blocks.forEach(function (node) {
        if (node.type.isTextblock) {
            var newAttrs = void 0;
            var action = actions.find(function (a) { return a.node === node.type.name; });
            if (action) {
                var newStyle = {
                    name: action.style,
                    value: action.step > 0 ? "" + action.step + action.unit : ''
                };
                if (node.attrs.style) {
                    var re = new RegExp(action.style + ":\\s?(\\d+)" + action.unit, 'i');
                    var match = node.attrs.style.match(re);
                    if (match) {
                        var newMargin = parseFloat(match[1]) + action.step;
                        newMargin = newMargin <= 0 ? '' : newMargin;
                        newStyle.value = "" + newMargin + (newMargin ? action.unit : '');
                    }
                }
                newAttrs = addStyles(node, [newStyle]);
            }
            if (newAttrs) {
                result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
            }
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
}; };
var ɵ0 = indentBlocks;
/**
 * @hidden
 */
export var indent = function (state, dispatch) {
    var isIndentableBlock = canBeIndented(state, indentRules);
    if (canIndentAsListItem(state)) {
        sinkListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(indentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
export var outdent = function (state, dispatch) {
    var isIndentableBlock = canBeIndented(state, outdentRules);
    if (canOutdentAsListItem(state)) {
        liftListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(outdentRules)(state, dispatch);
    }
};
export { ɵ0 };
