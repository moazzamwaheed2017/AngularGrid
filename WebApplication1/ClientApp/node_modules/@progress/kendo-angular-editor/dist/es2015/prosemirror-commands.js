import { isDevMode } from '@angular/core';
import { toggleMark, setBlockType } from 'prosemirror-commands';
import { AllSelection } from 'prosemirror-state';
import { sinkListItem, liftListItem } from 'prosemirror-schema-list';
import { getMarkRange, modifyMark, addStyles, changeBlockNode, changeStyle } from './prosemirror-core-utils';
import { isMarkActive, getActiveMarks, blockNodes, createContentNode, canBeIndented, canIndentAsListItem, canOutdentAsListItem } from './prosemirror-utils';
import { isPresent, toArray } from './util';
import { indentRules, outdentRules } from './config/indent-rules';
import { schema } from './config/schema';
const { blockquote, heading, listItem, paragraph, image } = schema.nodes;
/**
 * @hidden
 */
export const removeMark = (markType) => (state, dispatch) => {
    const { from, to, $cursor } = state.selection;
    if ($cursor) {
        let resolvedRange = getMarkRange($cursor, markType);
        dispatch(state.tr.removeMark(resolvedRange.from, resolvedRange.to, markType));
    }
    else {
        dispatch(state.tr.removeMark(from, to, markType));
    }
};
/**
 * @hidden
 */
export const removeAllMarks = ({ except = [] } = {}) => (state, dispatch) => {
    const { $cursor, from, to } = state.selection;
    const tr = state.tr;
    const excludedMarkTypes = toArray(except).map(mt => mt.name);
    if (!$cursor) {
        Object.keys(schema.marks)
            .map(m => schema.marks[m])
            .filter(mt => excludedMarkTypes.indexOf(mt.name) === -1)
            .forEach(mt => tr.removeMark(from, to, mt));
        dispatch(tr);
    }
};
/**
 * @hidden
 */
export const toggleBold = toggleMark(schema.marks.strong);
/**
 * @hidden
 */
export const toggleItalic = toggleMark(schema.marks.em);
/**
 * @hidden
 */
export const toggleUnderline = toggleMark(schema.marks.underline);
/**
 * @hidden
 */
export const toggleStrikethrough = toggleMark(schema.marks.strikethrough);
/**
 * @hidden
 */
export const toggleSubscript = toggleMark(schema.marks.subscript);
/**
 * @hidden
 */
export const toggleSuperscript = toggleMark(schema.marks.superscript);
/**
 * @hidden
 */
export const setFontFamily = (font) => (state, dispatch) => {
    const marks = state.schema.marks;
    const cmd = changeStyle(marks.style, {
        newValue: font,
        style: 'font-family',
        value: /^.+$/
    });
    return cmd(state, dispatch);
};
/**
 * @hidden
 */
export const setFontSize = (size) => (state, dispatch) => {
    const marks = state.schema.marks;
    const cmd = changeStyle(marks.style, {
        newValue: `${size}px`,
        style: 'font-size',
        value: /^.+$/
    });
    return cmd(state, dispatch);
};
/**
 * @hidden
 */
export const createLink = (attrs) => (state, dispatch) => {
    if (isMarkActive(state, schema.marks.link)) {
        modifyMark(schema.marks.link, attrs)(state, dispatch);
    }
    else if (state.selection.empty) {
        if (isDevMode() && !isPresent(attrs.text)) {
            throw new Error(
            // tslint:disable-next-line:max-line-length
            "Unable to create link without text. Please pass a 'text' property as part of the parameter or select any text in the Editor.");
        }
        const newLink = schema.text(attrs.text, [schema.marks.link.create(attrs), ...getActiveMarks(state).marks]);
        dispatch(state.tr.replaceSelectionWith(newLink, false));
    }
    else {
        toggleMark(schema.marks.link, attrs)(state, dispatch);
    }
};
/**
 * @hidden
 */
export const addOrUpdateStyle = (cssProp, value) => (state, dispatch) => {
    const marks = state.schema.marks;
    const selectionPresent = !state.selection.empty;
    if (selectionPresent || isMarkActive(state, marks.style)) {
        const cmd = changeStyle(marks.style, {
            style: cssProp,
            value: /^.+$/,
            newValue: value
        });
        cmd(state, dispatch);
    }
    else {
        const styles = marks.style.create({ style: `${cssProp}: ${value}` });
        const transaction = state.tr.addStoredMark(styles);
        dispatch(transaction);
    }
};
/**
 * @hidden
 */
export const applyHeading = (level) => setBlockType(heading, { level });
/**
 * @hidden
 */
export const applyParagraph = setBlockType(paragraph);
/**
 * @hidden
 */
export const applyBlockquote = setBlockType(blockquote);
/**
 * @hidden
 */
export const format = ({ tag }) => {
    if (tag.match(/h\d\b/)) {
        return applyHeading(parseInt(tag[1], 10));
    }
    else if (tag === 'p') {
        return applyParagraph;
    }
    else if (tag === 'blockquote') {
        return applyBlockquote;
    }
};
/**
 * @hidden
 */
export const insertImage = (attrs) => (state, dispatch) => {
    const node = image.createAndFill(attrs);
    dispatch(state.tr.replaceSelectionWith(node));
};
/**
 * @hidden
 */
export const insertText = (attrs) => (state, dispatch) => {
    dispatch(state.tr.insertText(attrs.text, attrs.from, attrs.to));
};
/**
 * @hidden
 */
export const setHTML = (content) => (state, dispatch) => dispatch(state.tr.setSelection(new AllSelection(state.doc)).replaceSelectionWith(createContentNode(content)));
/**
 * @hidden
 * Aligning block elements in the selection.
 *
 * @returns {boolean} - Returns true if any alignment is applied.
 */
export const alignBlocks = (actions) => (state, dispatch) => {
    const blocks = blockNodes(state);
    const tr = state.tr;
    let result = false;
    blocks.forEach(node => {
        if (node.type.isTextblock) {
            let newAttrs = {};
            const action = actions.find(n => n.node === node.type.name);
            if (action) {
                newAttrs = addStyles(node, action.style);
            }
            result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
};
/**
 * Indenting block elements in the selection.
 *
 * @returns {boolean} - Returns true if any indentation is applied.
 */
const indentBlocks = (actions) => (state, dispatch) => {
    const blocks = blockNodes(state);
    const tr = state.tr;
    let result = false;
    blocks.forEach(node => {
        if (node.type.isTextblock) {
            let newAttrs;
            const action = actions.find(a => a.node === node.type.name);
            if (action) {
                const newStyle = {
                    name: action.style,
                    value: action.step > 0 ? `${action.step}${action.unit}` : ''
                };
                if (node.attrs.style) {
                    const re = new RegExp(`${action.style}:\\s?(\\d+)${action.unit}`, 'i');
                    const match = node.attrs.style.match(re);
                    if (match) {
                        let newMargin = parseFloat(match[1]) + action.step;
                        newMargin = newMargin <= 0 ? '' : newMargin;
                        newStyle.value = `${newMargin}${newMargin ? action.unit : ''}`;
                    }
                }
                newAttrs = addStyles(node, [newStyle]);
            }
            if (newAttrs) {
                result = changeBlockNode(state, dispatch, tr, node, node.type, newAttrs) || result;
            }
        }
    });
    if (result) {
        dispatch(tr.scrollIntoView());
    }
    return result;
};
const ɵ0 = indentBlocks;
/**
 * @hidden
 */
export const indent = (state, dispatch) => {
    const isIndentableBlock = canBeIndented(state, indentRules);
    if (canIndentAsListItem(state)) {
        sinkListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(indentRules)(state, dispatch);
    }
};
/**
 * @hidden
 */
export const outdent = (state, dispatch) => {
    const isIndentableBlock = canBeIndented(state, outdentRules);
    if (canOutdentAsListItem(state)) {
        liftListItem(listItem)(state, dispatch);
    }
    else if (isIndentableBlock) {
        indentBlocks(outdentRules)(state, dispatch);
    }
};
export { ɵ0 };
