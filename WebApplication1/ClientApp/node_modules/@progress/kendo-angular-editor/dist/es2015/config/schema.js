import { Schema } from 'prosemirror-model';
import { isEmpty, serializeDOMAttrs, removeEmptyEntries, removeEntries } from '../util';
const SLOT = 0; //https://prosemirror.net/docs/guide/#schema.serialization_and_parsing
const commonAttributes = () => {
    return {
        class: { default: null },
        id: { default: null },
        style: { default: null }
    };
};
const ɵ0 = commonAttributes;
const ɵ1 = (dom) => ({
    href: dom.getAttribute('href'),
    target: dom.getAttribute('target'),
    title: dom.getAttribute('title')
}), ɵ2 = (mark) => [
    'a',
    // Add default value for href. Otherwise the link is not rendered properly(blue with underline)
    Object.assign({}, { href: '' }, removeEmptyEntries(mark.attrs)),
    SLOT
], ɵ3 = () => ['em', SLOT], ɵ4 = (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null, ɵ5 = () => ['strong', SLOT], ɵ6 = () => ['code', SLOT], ɵ7 = () => ['u', SLOT], ɵ8 = () => ['del', SLOT], ɵ9 = () => ['sub', SLOT], ɵ10 = () => ['sup', SLOT], ɵ11 = (dom) => ({
    style: dom.getAttribute('style')
}), ɵ12 = (mark) => ['span', Object.assign({}, removeEmptyEntries(mark.attrs)), SLOT];
/**
 * @hidden
 */
const marks = {
    // :: MarkSpec A link. Has `href` and `title` attributes. `title`
    // defaults to an empty string. Rendered and parsed as an `<a>`
    // element.
    link: {
        attrs: {
            href: { default: '' },
            target: { default: null },
            title: { default: null }
        },
        inclusive: false,
        parseDOM: [
            {
                getAttrs: ɵ1,
                tag: 'a[href]'
            }
        ],
        toDOM: ɵ2
    },
    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
    // Has parse rules that also match `<i>` and `font-style: italic`.
    em: {
        parseDOM: [{ tag: 'i' }, { tag: 'em' }, { style: 'font-style=italic' }],
        toDOM: ɵ3
    },
    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
    // also match `<b>` and `font-weight: bold`.
    strong: {
        parseDOM: [
            { tag: 'strong' },
            // This works around a Google Docs misbehavior where
            // pasted content will be inexplicably wrapped in `<b>`
            // tags with a font-weight normal `{tag: 'b', getAttrs: node => node.style.fontWeight != 'normal' && null}`,
            {
                // According to the docs, the value can be a DOM element (for tag rules) or a string (for style rules).
                getAttrs: ɵ4,
                style: 'font-weight'
            }
        ],
        toDOM: ɵ5
    },
    // :: MarkSpec Code font mark. Represented as a `<code>` element.
    code: {
        parseDOM: [{ tag: 'code' }],
        toDOM: ɵ6
    },
    // :: MarkSpec An underline mark. Rendered as a `<u>` element.
    // Parse rules also match `text-decoration: underline`.
    underline: {
        parseDOM: [{ tag: 'u' }, { style: 'text-decoration=underline' }],
        toDOM: ɵ7
    },
    // :: MarkSpec A strikethrough mark. Rendered as a `<del>` element.
    // Parse rules also match `<s>`, `<strike>`, `text-decoration: line-through`.
    strikethrough: {
        parseDOM: [{ tag: 'del' }, { tag: 's' }, { tag: 'strike' }, { style: 'text-decoration=line-through' }],
        toDOM: ɵ8
    },
    // :: MarkSpec A subscript mark. Rendered as a `<sub>` element.
    // Parse rules also match `vertical-align: sub`.
    subscript: {
        parseDOM: [{ tag: 'sub' }, { style: 'vertical-align=sub' }],
        toDOM: ɵ9
    },
    // :: MarkSpec A superscript mark. Rendered as a `<sup>` element.
    // Parse rules also match `vertical-align: super`.
    superscript: {
        parseDOM: [{ tag: 'sup' }, { style: 'vertical-align=super' }],
        toDOM: ɵ10
    },
    style: {
        attrs: Object.assign({}, commonAttributes(), { style: {} }),
        parseDOM: [
            {
                // think about a way to remove span tags with empty style attributes or no style attributes at all
                getAttrs: ɵ11,
                tag: 'span[style]'
            }
        ],
        toDOM: ɵ12
    }
};
const ɵ13 = (node) => (isEmpty(node.attrs) ? ['p', SLOT] : ['p', removeEmptyEntries(node.attrs), SLOT]), ɵ14 = (node) => ['blockquote', removeEmptyEntries(node.attrs), SLOT], ɵ15 = () => ['hr'], ɵ16 = (dom) => Object.assign({}, serializeDOMAttrs(dom), { level: 1 }), ɵ17 = (dom) => Object.assign({}, serializeDOMAttrs(dom), { level: 2 }), ɵ18 = (dom) => Object.assign({}, serializeDOMAttrs(dom), { level: 3 }), ɵ19 = (dom) => Object.assign({}, serializeDOMAttrs(dom), { level: 4 }), ɵ20 = (dom) => Object.assign({}, serializeDOMAttrs(dom), { level: 5 }), ɵ21 = (dom) => Object.assign({}, serializeDOMAttrs(dom), { level: 6 }), ɵ22 = (node) => {
    const attrs = removeEntries(node.attrs, key => key !== 'level');
    return ['h' + node.attrs.level, removeEmptyEntries(attrs), SLOT];
}, ɵ23 = () => ['pre', ['code', SLOT]], ɵ24 = (dom) => ({
    alt: dom.getAttribute('alt'),
    height: dom.getAttribute('height'),
    src: dom.getAttribute('src'),
    width: dom.getAttribute('width')
}), ɵ25 = (node) => ['img', removeEmptyEntries(node.attrs)], ɵ26 = () => ['br'], ɵ27 = (node) => ['li', removeEmptyEntries(node.attrs), SLOT], ɵ28 = (dom) => ({
    order: dom.hasAttribute('start') ? parseInt(dom.getAttribute('start'), 10) : 1
}), ɵ29 = node => (node.attrs.order === 1 ? ['ol', SLOT] : ['ol', { start: node.attrs.order }, SLOT]), ɵ30 = () => ['ul', SLOT];
/**
 * @hidden
 */
const nodes = {
    // :: NodeSpec The top level document node.
    doc: {
        content: 'block+'
    },
    // :: NodeSpec A plain textblock paragraph. Represented
    // as a `<p>` element in the DOM.
    paragraph: {
        attrs: Object.assign({}, commonAttributes()),
        content: 'inline*',
        group: 'block',
        parseDOM: [
            {
                getAttrs: serializeDOMAttrs,
                tag: 'p'
            }
        ],
        toDOM: ɵ13
    },
    // :: NodeSpec A blockquote (`<blockquote>`) which wraps one or more blocks.
    blockquote: {
        attrs: Object.assign({}, commonAttributes()),
        content: 'inline*',
        defining: true,
        group: 'block',
        parseDOM: [{ tag: 'blockquote' }],
        toDOM: ɵ14
    },
    // :: NodeSpec A horizontal (`<hr>`) rule.
    horizontalRule: {
        group: 'block',
        parseDOM: [{ tag: 'hr' }],
        toDOM: ɵ15
    },
    // :: NodeSpec A heading textblock with a `level` attribute that
    // has to hold a number from 1 to 6. Parsed and serialized as an `<h1>` to
    // an `<h6>` element.
    heading: {
        attrs: Object.assign({ level: { default: 1 } }, commonAttributes()),
        content: 'inline*',
        defining: true,
        group: 'block',
        parseDOM: [
            { tag: 'h1', getAttrs: ɵ16 },
            { tag: 'h2', getAttrs: ɵ17 },
            { tag: 'h3', getAttrs: ɵ18 },
            { tag: 'h4', getAttrs: ɵ19 },
            { tag: 'h5', getAttrs: ɵ20 },
            { tag: 'h6', getAttrs: ɵ21 }
        ],
        toDOM: ɵ22
    },
    // :: NodeSpec A code listing. Prevents marks or non-text inline
    // nodes by default. Represented as a `<pre>` element with a
    // `<code>` element inside.
    codeBlock: {
        code: true,
        content: 'text*',
        defining: true,
        group: 'block',
        marks: '',
        parseDOM: [
            {
                preserveWhitespace: 'full',
                tag: 'pre'
            }
        ],
        toDOM: ɵ23
    },
    // :: NodeSpec The text node.
    text: {
        group: 'inline'
    },
    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
    // `alt`, and `href` attributes. The last two default to an empty
    // string.
    image: {
        attrs: Object.assign({}, commonAttributes(), { alt: { default: null }, height: { default: null }, src: {}, width: { default: null } }),
        draggable: true,
        group: 'inline',
        inline: true,
        parseDOM: [
            {
                getAttrs: ɵ24,
                tag: 'img[src]'
            }
        ],
        toDOM: ɵ25
    },
    // :: NodeSpec A hard line break. Represented as a `<br>` element in the DOM.
    hardBreak: {
        group: 'inline',
        inline: true,
        parseDOM: [{ tag: 'br' }],
        selectable: false,
        toDOM: ɵ26
    },
    // :: NodeSpec A list item. Represented as a `<li>` element.
    listItem: {
        attrs: Object.assign({}, commonAttributes()),
        content: 'paragraph block*',
        marks: '_',
        parseDOM: [{ tag: 'li' }],
        toDOM: ɵ27
    },
    // :: NodeSpec An ordered list. Represented as an `<ol>` element.
    // Has a single `order` attribute which determines the number at which
    // the list starts counting. Defaults to 1.
    orderedList: {
        attrs: {
            order: {
                default: 1
            }
        },
        content: 'listItem+',
        group: 'block',
        parseDOM: [
            {
                getAttrs: ɵ28,
                tag: 'ol'
            }
        ],
        toDOM: ɵ29
    },
    // :: NodeSec An unordered list. Represented as a `<ul>` element.
    bulletList: {
        content: 'listItem+',
        group: 'block',
        parseDOM: [{ tag: 'ul' }],
        toDOM: ɵ30
    }
};
/**
 * @hidden
 */
export const schema = new Schema({
    marks,
    nodes
});
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9, ɵ10, ɵ11, ɵ12, ɵ13, ɵ14, ɵ15, ɵ16, ɵ17, ɵ18, ɵ19, ɵ20, ɵ21, ɵ22, ɵ23, ɵ24, ɵ25, ɵ26, ɵ27, ɵ28, ɵ29, ɵ30 };
